/** https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA
 * HTTP vs HTTPS 区别：
 * 1.http采用明文发送，https采用密文发送，所以https安全性高
 * 2.http端口80，https：443
 * 3.https要购买证书，成本高
 * 4.https请求效率低（需要TLS握手，但握手后通信效率接近）
 * 5.https实际上是http+ssl/TLS（SSL已废弃，现在用TLS）
 * 
 * === HTTPS 加密过程（TLS 1.2/1.3）===
 * 
 * 【准备阶段】
 * 1. 服务器生成公钥/私钥对
 * 2. 服务器向 CA（证书颁发机构）申请证书，提交公钥、域名等信息
 * 3. CA 验证服务器身份后：
 *    - 用 Hash 算法（如SHA-256）对服务器信息生成消息摘要
 *    - 用 CA 的私钥对消息摘要进行签名，生成数字签名
 *    - 将服务器公钥、域名、数字签名等打包成数字证书
 *    - 颁发证书给服务器
 * 
 * 【HTTPS 握手阶段】
 * 1. 客户端发起 HTTPS 请求（Client Hello）
 *    - 发送支持的 TLS 版本、加密套件、随机数等
 * 
 * 2. 服务器响应（Server Hello）
 *    - 返回数字证书（包含服务器公钥、CA 签名等）
 *    - 选择加密套件、发送随机数
 * 
 * 3. 客户端验证证书：
 *    - 用浏览器预置的 CA 公钥验证数字签名，得到消息摘要A
 *    - 用相同的 Hash 算法计算证书信息，得到消息摘要B
 *    - 比对 A 和 B 是否一致（验证证书未被篡改）
 *    - 验证证书有效期、域名、吊销状态等
 * 
 * 4. 密钥交换（现代方式 - ECDHE/DHE）：
 *    ⭐ 重点：对称密钥不会在网络上传输！
 *    - 客户端生成 ECDHE 参数（临时公钥）发送给服务器
 *    - 服务器生成 ECDHE 参数（临时公钥）发送给客户端
 *    - 双方使用对方的公钥和自己的私钥，通过 ECDHE 算法独立计算出相同的"预主密钥"
 *    - 基于预主密钥和之前的随机数，双方各自生成相同的对称加密密钥
 *    - 提供前向安全：即使服务器私钥泄露，历史通信也无法被破解
 * 
 *    （旧方式 - RSA 密钥交换，已不推荐）：
 *    - 客户端生成随机对称密钥，用服务器公钥加密后发送
 *    - 服务器用私钥解密得到对称密钥
 *    - 缺点：无前向安全，私钥泄露会导致所有历史通信被破解
 * 
 * 5. 开始加密通信：
 *    - 使用协商好的对称密钥（如 AES-256-GCM）加密所有数据
 *    - 使用 HMAC 或 AEAD 保证数据完整性和认证
 * 
 * 【核心概念】
 * - 消息摘要：用 Hash 算法（SHA-256）对数据生成固定长度的摘要，用于验证数据完整性
 * - 数字签名：用私钥对消息摘要进行签名，证明数据来自特定方且未被篡改
 * - 数字证书：由 CA 签发，证明"这个公钥确实属于这个域名"，防止中间人攻击
 * - 前向安全（Forward Secrecy）：即使长期私钥泄露，过去的会话密钥也无法被推导出来
 * 
 * 【为什么需要非对称+对称混合加密】
 * - 非对称加密（RSA/ECDHE）：安全但慢，用于身份验证和密钥交换
 * - 对称加密（AES）：快速高效，用于大量数据传输
 * - 组合使用：用非对称加密安全地协商对称密钥，再用对称密钥加密实际数据
 * 
 */

/**
 * tcp udp的区别
 * tcp：面向连接的，可靠的，通过字节流传输的协议，支持1对1通信
 * udp：面向无连接，不可靠，通过报文传输的协议，支持1对多
 * 其中：
 * 面向连接：通信前需要3次握手，通信结束要4此挥手
 * 可靠性：，不丢包，按顺序,
 * 通过：确认应答+序列号、超时重传、拥塞控制、流量控制、校验和
 */

/**
 * http 头部有哪些字段
 * 1.cache-control
 * 2.Connection:Keep-Alive
 * 3.Content-Type(text/html,image/png,application/json,multipart/form-data)
 * 7.Accept-encoding/content-encoding(gzip,deflat,br)
 * 4.ETag(If-None-Match)
 * 5.Last-Modified(If-Modified-since)
 * 6.reffer
 *  */

/**
 * http有哪些请求
 * 1.options：预检请求，跨域时发送options来检测服务器是否支持实际请求
 * 2.get/post：a.在浏览器设置中get有长度限制，post没有；b.get请求的参数可以被浏览器缓存下来，post不能c.get时幂等的而post不是
 * 3.put：幂等用来改变信息
 * 4.head:只请求头部信息
 */

/**
 * 为什么要减少http请求
 * 1.请求本身资源很小，可能请求头比实际数据还大，这种请求多了，传输自然就慢了
 * 2.http1.1只能串行发送，也就是第100个请求要等第99个请求完成才能发送，这会造成较大的网络延迟，而网络延迟就是合并请求的主要动力
 * 3.通过dns获得实际的ip地址也是比较浪费时间，即使有dns缓存，那也需要查找
 */
/**
 * 如何减少http请求
 * 1.减少图片请求（1.使用图片精灵2.使用内联图片主要是data：url方式）
 * 2.减少脚本文件和css文件的请求
 */

/**
 * http2
 * 1. 1.x中采用文本传输，2采用2进制传输（有多种文本形式，要使用就必须考虑多种场景，二进制则方便健壮）
 * 2. 采用多路复用，一个tcp连接可以有多条流，对端可以通过帧标识知道属于哪个请求。这样就可以避免队头阻塞，极大提高性能（帧代表最小的数据单位，每个帧会标识出属于哪个流，流由多个帧组成）
 * 3.对头部压缩
 * 4.服务器可以进行推送（请求style.css，服务器还会多发一个script.js）
 * 缺点： tcp队头阻塞。 如果HTTP / 2 连接双方的网络中有一个数据包丢失， 或者任何一方的网络出现中断， 整个TCP连接就会暂停， 丢失的数据包需要被重新传输。 因为TCP是一个按序传输的链条， 因此如果其中一个点丢失了， 链路上之后的内容就都需要等待。
 */

/**
 * html优化
 * 1.减少http请求
 * 2.利用好浏览器强缓存和协商缓存
 * 3.利用cdn，内容分发网络，会选择对用户响应最快的节点来响应用户
 * 4.用户端可以设置accept-encoding，服务端可以设置content-encoding
 * 5.css放头部，js放底部，都可以加快首屏的加载时间
 * 6.最好使用外联js和css，因为内联虽然减少请求但增大了文件的体积，且外联之后能被浏览器缓存
 * 7.减小js、css体积，即删除不必要的字符和空格
 */

/**
 * html5新特性
 * 1.语义化标签（header、footer、nav、aside）
 * 2.web存储增加，localstorge，sessionstorage
 * 3.增加音频，audio，vedio
 * 4.websocket
 */

/**
 * 为什么使用vue
 * 1.首先第一年有接触过一个vue项目，算是边看边学了
 * 2.网上查询相比react，vue比较适合小型项目3.就是学长的建议
 */



/**
 * script属性和link属性
 * 下载script文件和执行script文件都会阻塞dom解析
 * 加上defer就是下载不会阻塞，下载号后最后执行
 * async下载不会阻塞，下载号后立即执行
 * 1.script:
 * a.src b.type="text/javascript" c.defer/async
 * 2.link:
 * rel="stylesheet" href="" type="text/css"
 */

/**
 * 常用meta
 * 1.优化移动设备name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,use-scalable=no"
 * 2.搜索隐形关键字name="keywords" content="关键字1，····"
 * 3. name="description" content="网页描述"
 * 4.不缓存 http-equiv="cache-control" content="no-cache"
 * 5. 设置字符集 <meta charset="utf-8">
 */

/**
 * webassembly？
 * 1.生成的文件是二进制的，意味着更小的文件，更快的下载分发
 * 2.可以由非js语言来编写，主要用于计算复杂的地方。
 */